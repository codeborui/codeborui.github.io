---
layout: post
title:  "Designing Data-Intensive Applications读书笔记(9)"
categories: DDIA
tags:  读书笔记 分布式
author: Borui
---

* content
{:toc}

# Consistency and Consensus
分布式环境里很多故障都会发生,最简单的做法就是整个服务失败,然后告诉用户错误信息.但在web环境中这是不可接受的,因此需要我们进行容错处理.这里我们将描述一些分布式容错算法,面临的故障包括包丢失,乱序,重发和任意延迟,包括时钟最多只是近似的环境,还包括节点暂停(可能是gc导致的)或故障.

建立容错机制最好的方法,就是能找到提供有用保证的通用抽象,然后让应用程序运行在这层抽象上.**就像通过事务,应用程序无需关心节点故障A,并发I和存储问题D.分布式系统中,最重要的抽象就是一致性**,这里一致性的含义是使得所有节点就某项决定达成共识,这样我们就不用考虑网络故障和节点失败问题了.

和事务类似,我们需要知道抽象的边界在哪里,什么能做什么不能做,提供的保证包含哪些,一致性的局限在哪里.这里的一致性分为内部一致性和外部一致性,内部一致性是系统内部达成一致,外部一致性是应用看到的视图(就算内部数据并不一致,可以通过某些手段返回给外部一致的结果).并且和事务的一致性都不一样.

## 一致性保证
大部分复制数据库都提供了**最终一致性**,这意味着如果你停止写入然后等不知道多久的时间,最终所有的读取操作都会返回一样的结果.也就是说不一致是暂时,最终都会达成一致.最终一致性更好的叫法是**收敛**,它并不保证什么时候这些副本会一致.

更强的一致性模型会有性能损失和较差的容错性.但是更易于使用.分布式一致性模型和事务里的隔离级别有些相似,但除了有些重叠大部分概念还是相互独立的.事务隔离性主要是为了避免并发执行事务时的竞态条件.而分布式一致性主要是为了协调副本的状态,在延迟和错误存在的条件下.

## 线性一致性
线性一直性,又叫做原子一致性,强一致性,瞬时一致性或者外部一致性.基本思路就是使得系统看起来好像只有一份数据,并且所有操作都是原子的.这样的话即使实际上有多份副本,但应用层并不需要了解.

### 线性一致性和可串行化
可串行化是事务的一种隔离级别,每个事务都会读写多个对象.事务保证事务的执行行为就像按照某种线性顺序执行结果一样(每个事务在下一个事务开始前结束).即使事务实际执行的顺序和线下顺序并不一致.

线性一致性是针对读写的最新保证,它并不将所有操作都封装到事务里,所以不能避免写倾斜问题,除非采用其他的手段.

一个数据库可能提供两种保证,这被称为严格可串行化或者强单一副本可串行化.**基于两阶段锁和实际串行执行实现的可串行化是典型的线性一致的**.但是ssi就不是线性一致的.因为读取操作都是从快照读取的,不包含最新写入的值.

### 依赖线性一致性
#### 锁和选主
单主复制系统需要确保系统有且只有一个主.常用的选主方法就是使用一个锁,无论锁怎么实现都必须是线性一致的,所以节点必须统一某个节点获取了锁.协调服务例如zk和etcd都被用来选主和实现分布式锁,还可以使用fencing令牌实现选择和锁.
#### 约束和唯一性保证
唯一性约束在数据库里很常见,这时也需要线性一致性.

实际中,有时候可以放宽约束.这时候就不一定需要线性一致性了.
#### 跨渠道的时间依赖
不同的信息交互渠道存在时,就需要线性一致性.

### 实现线性一致性系统
+ 单主节点(有可能线性一致):如果读写都发送到主上,或者同步更新副本,则有可能是线性一致的.但是这取决于设计方式.
+ 共识算法(线性一致):和单主复制结构类似,但能够避免脑裂和损坏副本.
+ 多主复制(不能线性一致):并发写在多个节点上而且是异步复制,还会因此产生冲突,这种冲突就是缺乏单一数据副本的产物.
+ 无主架构(可能不是线性一致的):版本向量+WRN看起来是强一致的,但是LWW里的时钟并不能保证和实际发生的时间是一致的,而且Sloppy quorums也会破坏线性一致性.
#### 线性一致性和quorums
尽管看起来严格的quorum读写是线性一致的,但由于网络延迟的存在,仍然会有不一致出现:
![Figure 9-6. A nonlinearizable execution, despite using a strict quorum](https://raw.githubusercontent.com/codeborui/codeborui.github.io/master/img/13.png)
这种情形下可以通过牺牲性能来获取线性一致性:读者必须执行读修复,写者必须读取最新的数据.Cassandra进行读时修复,但是由于采用lww解决冲突因此在并发写入时会丢失线性一致性.
### 线性一致性的代价
#### CAP
+ 如果应用需要线性一致性,而当部分副本因为网络问题无法和其他副本连接,那么这些副本不能处理任何请求,只能等待网络恢复或者返回用户错误信息,换句话说,它们是不可用的.
+ 如果应用不提供线性一致性,每个副本都可以单独处理请求.当出现网络问题时,仍然能够可用,但无法保持线性一致性了.

不需要线性一致性的应用能够更容忍网络的问题,这个观点就是众所周知的CAP理论.