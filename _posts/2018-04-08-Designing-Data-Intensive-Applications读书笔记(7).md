---
layout: post
title:  "Designing Data-Intensive Applications读书笔记(7)"
categories: DDIA
tags:  读书笔记 分布式
author: Borui
---

* content
{:toc}

# Transactions
现实中的数据系统,会有很多故障发生:
1. 数据系统或者硬件随时有可能故障,包括写操作正在执行时.
2. 应用程序随时可能宕机.
3. 网络故障使得应用无法连接数据库,或者数据库节点之间无法连接.
4. 客户端获取到的数据只被部分更新.
5. 客户端之间的竞态条件导致难以预料的bug.

事务用来简化容错机制实现.事务机制使得一些读和写原子写入,要么都成功,要么都失败.如果失败了,应用层可以安全地进行重试.有了事务,应用的错误处理会变得非常简单,不用担心部分写入成功部分写入失败了.事务并不是一个自然规律,事务的产生是有原因的,就是为了应用访问数据库时,能**简化编程模型**.通过使用事务,应用层无需关心潜在的错误可能和并发问题.当然也并非所有的应用都需要事务,有时候可以通过弱化事务保证甚至完全抛弃事务,来获得更高的性能和可用性.那么到底我们的程序要不要使用事务呢?这里需要深入了解事务究竟能带来什么样的**安全保证**以及伴随这些保证牺牲了什么.尽管事务看起来很直观,实际上有很多微秒但是重要的细节.

## 难以掌握的事务概念
几乎所有的关系型数据库和一些非关系型数据都实现了事务.2000年末nosql开始流行,通过提供新的数据模型和默认提供备份和分区来改善关系型数据库的现状.然而事务却被忽略了,很多新兴的数据库完全抛弃了事务,或者重新定义事务,使得事务包含了较弱的保证.
### ACID的含义
事务提供的安全保证通常被描述为**ACID**,代表了**Atomicity, Consistency, Isolation, and Durability**,是为数据库容错机制提出的精确术语.但是实际上,一个数据库的ACID实现不同于另一个数据库系统的实现,单就**隔离性**而言都有很多模棱两可的地方.因此ACID的实现有时候可能会和你的期望是不一致的.不满足ACID条件的系统有时被称为**BASE**,也就是**Basically Available, Soft state, and Eventual consistency**.
#### Atomicity
事实上,原子代表那些无法被切割成更小部分的东西.在不同的计算机分支里,原子代表着相似但又有微秒差别的东西.例如,在多线程语言里,如果一个线程执行一个原子操作,这意味着另一个线程不会看到执行到一半的结果,系统只可能处在执行前或者执行后的状态,没有办法处在中间状态.相比之下,在ACID语境下,原子性不是关于并发的,它不是用来表示多个进程同事访问同一个数据,这部分是通过I,也就是isolation.

ACID的原子性描述了如果一个客户端执行多个写操作,而其中某个写操作发生了错误.如果这些写操作被组合成一个原子的事务,那么该事务由于某个写操作的错误从而无法提交完成,因此这个事务就需要被取消.那么事务里包含的任何写操作都需要被丢弃.如果没有原子性,当错误发生时很难定位哪些操作已经执行成功,而哪些操作还未执行.应用程序可以尝试重试,但这导致一些操作被执行两次,从而出现重复或者不正确的数据.原子性简化了这个问题,如果一个事务被取消了,那么应用程序可以确信没有发生任何的更改,可以安全地进行重试操作.
#### Consistency
一致性这个词汇被严重的滥用了:
1. 在异步化的复制系统里,副本一致性和最终一致性被提出来.
2. 一致性hash是一种分区的方法,一些系统用它来进行重新调整.
3. 在CAP理论里,一致性被用来代表线性一致性.
4. 在ACID环境下,一致性是指数据库处于"好状态"的特定于应用程序的概念.

这一个词就有四个不同的含义,在ACID环境下,如果当前数据库在不变量约束下是正确的,然后开始一个事务,然后事务中所有的写操作都是保证了这个约束,那么我们可以确信不变量约束始终是安全的.怎么理解呢?具体可以参考这里[如何理解数据库事务中的一致性的概念](https://www.zhihu.com/question/31346392/answer/362597203).核心在于,一致性是一种应用层的特性,即应用程序从一个正确的状态迁移到另一个正确的状态,这时我们说应用程序保持了一致性,所谓正确的状态是应用层也就是开发者定义的,而不是数据库的特性.而事务就是通过AID手段来保持一致性的,状态的迁移不是瞬时的,是有中间过程的,而事务能够保证状态的安全迁移.
#### Isolation
大部分的数据库会被客户端并发访问同一行记录,这时候就会遇到并发问题(竞态条件).因此隔离性的含义就是说,并发执行中的事物之间都是互相隔离的.经典数据库教材里将隔离性定义成**可序列化**,这意味着每个事物都能保证整个数据库只有它自己在运行.数据库来保证,当事物提交的时候,得到的最终结果和事务一个接着一个的运行结果是一样的,尽管事实上他们是并发运行的.但是实际上,数据库很少采用可序列化这个隔离级别,因为太伤性能了.
#### Durability
数据库系统本身的目的就是为了提供一个安全存储数据的地方,防止数据的丢失.事务的持久化是指一旦事务提交成功,数据一定不会被丢失.在单机系统中,持久化通常是指数据被写入磁盘中,通常这个持久化过程会包含预写式日志或者相似的结构,从而当磁盘数据损坏后可以恢复.而在分布式系统中,持久化意味着数据被拷贝到了一些节点上,为了保证持久化,数据库必须等这些写操作和备份都完成了,才能让一个事务成功提交.当然,百分百的数据安全是不存在的,如果不巧你所有备份的磁盘都挂掉了,你的数据就一定丢失了.

### 单目标与多目标操作
总的来说,在ACID中,原子性和隔离性描述的都是在同一个事务里,如果一个客户端执行多个写请求数据库应该怎么做.
1. 原子性:如果写序列执行过程中发生了错误,事务应该回滚,而写操作带来的影响应该被丢弃.也就是说事务保证你不用担心部分失败,要么都成功要么都失败.
2. 隔离性:并发执行的事务不应该影响彼此.例如如果一个事务执行了多个写操作,另一个事务要么看到全部的写入,要么什么也看不到.

多目标事务需要确定哪些读和写操作是隶属于相同的事务的,在关系型数据库里主要是基于客户端的TCP连接,任何连接中的开始事务和提交事务声明之间的操作都被认为是同一个事务.而对于很多非关系型数据库,则没有提供这种接口出来.
#### 单目标写入
当单个目标写入时,原子性和隔离性就会起作用,这是数据库默认的操作.原子性可以通过**日志**恢复来实现.隔离性可以通过目标上**加锁**,来保证只有一个线程能写入.

一些数据库还提供一些更复杂的单目标原子操作,例如自增长,类似的还有CAS.

当多个客户端试着同时写入同一个目标时,这些操作能防止更新的丢失.但是通常意义上来说他们并不是事务,有时被称为**轻量级事务**.事务是一种将多个操作行为或者多目标操作集中到一个执行单元的机制.
#### 多目标事务
许多分布式数据系统都放弃了多目标事务的实现,因为很难跨分区实现,而且在高可用和高性能的场景需求下,多目标事务会成为瓶颈.但是我们的系统不可能只依赖kv数据库或者单目标操作.
1. 在关系型数据库中,某个table依赖的外键要更新,那么就需要多目标事务同事更新他们.
2. 在文档型数据库中,当非规范化的信息更新时,会涉及到多个文档内容的更新,也需要事务.
3. 对于存在辅助索引的数据库,索引的更新操作也需要事务保护.

#### 处理错误和取消操作
事务一个关键的特性就是,当错误发生时可以被取消然后安全的重试.而对于无主副本架构里,设计原则就是数据库尽最大能力去做,但是不会回滚已经做过的事情.因此这就需要客户端去处理异常信息.

重试操作是一种简单并且有效的错误处理机制,但是并不完美:
+ 如果事务实际上成功了,但是网络失败了,这是客户端认为还是失败了,这时候如果重试会导致事务执行两次,除非你有额外的去重机制.
+ 如果错误是由于系统超载了,那么重试事务其实会加重问题.因此我们可以尝试限制重试次数,使用指数退避,或者把超载错误和其他错误分开对待.
+ 面对瞬时异常(例如死锁了,违反隔离性了,网络问题啊)重试是有意义的,但是对于永久性错误(违反了约束条件)重试是毫无意义的.
+ 如果事务执行除了数据库外还有副作用,并且即使取消事务了副作用仍然会发生,那么重试就会有问题.比如事务开启了就会发送邮件出去.(这有点儿分布式事务的意味,为了解决这个问题,可以引入两阶段提交)
+ 重试的时候客户端进程挂掉了,那么很显然数据也就没了.

## 弱隔离级别
如果两个事务触及的相同数据，它们可以安全的并行运行。竞态条件只在一个事务读取数据同时另一个事务并发更改该数据时起作用，或者两个事务同时试图更改同样的数据。长久以来，数据库通过事务的隔离性将并发问题隐藏掉，使得开发者不需要考虑并发问题。

**序列化**的隔离级别