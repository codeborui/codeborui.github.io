---
layout: post
title:  "Designing Data-Intensive Applications读书笔记(5)"
categories: DDIA
tags:  读书笔记 分布式
author: Borui
---

* content
{:toc}

# Replication
Replication意味着将一份数据的副本保存在不同的机器上.为什么要备份呢?
1. 保证你的数据更靠近你的用户(用以减少延迟,比如CDN).
2. 当部分数据失效了,系统能够持续工作.
3. 增加可读机器的数量,提供更好的读效率(提高了读操作的吞吐量).

数据的复制最大的困难在于处理复制数据的更新变化,也就是保持副本的一致性.遇到的问题有很多,包括是同步还是一部进行备份操作?如何处理失败的备份?这一章主要讲述了三种备份架构,以及一致性问题.

## Leaders and Followers
在多副本的情景下,我们如何确保我们的数据都存在于所有的副本机器上呢?最常用的架构就是**leader-based replication**,也被称为**active/passive**或者**master–slave replication**.
1. 一台副本机器被指派为leader,所有的客户端的写操作请求,都必须发送到leader副本机器上,leader会先把数据写到本地磁盘上.
2. 其他的副本机器被称为followers.leader除了负责将数据写入本地磁盘,还需要将数据的变化发送给所有的followers,一般都是以**replication log**或者**change stream**的形式.所有的followers从leader那里获取到日志,然后更新自己本地的数据文件,并且保持和leader一致的处理顺序.
3. 当一个客户端想要从数据库读取数据时,它可以把请求发送给任意leader或者followers.但是写操作必须发送给leader.

需要关系型数据库内置的复制模式就是这种模式.一些非关系型数据库也采用这种模式.不近数据库使用这种模式,就连分布式的消息代理Kafka也采用这种模式.

### 同步异步复制
复制的一个重要的细节就是,是同步复制还是异步复制.一般复制操作都是很快的,但是很难保证复制操作到底会延迟多久.

同步复制的优势是保证所有的followers都和leader是一致的,就算leader挂掉了,随便一个follower都能顶上.但是劣势也很明显,如果某个follower由于某种原因迟迟没有回应,那么这次写操作就会被阻塞,直至这个follower恢复正常.实际上,同步复制是不可操作的,任意一个follower的故障就会将整个服务阻塞,因此如果你在一个数据库配上设置为同步,通常意味着其中一个follower是同步的,而其他follower的复制操作仍然是异步的.当一个同步的follower不可用的时候,就会将一个异步的follower升级为同步follower,这样做的好处是,始终保证数据存在至少两个节点上,这种方式被称为**semi-synchronous**.

通常情况下,leader-based模式都是完全异步进行复制.这意味着如果leader发生了故障,会导致一些写入的数据不可读从而丢失了.但是完全异步的复制有这样一个优势,就是就算所有的follower都故障了,leader仍然能够提供服务.弱化数据的保障看起来不是一个好的选择,但是异步复制正在被广泛使用,尤其是有很多follower分布在世界各地的时候.

**chain replication**是一种异步复制.节点按照链式排列,而不是传统的星状排列.
1. 所有的读操作必须发送到尾节点(primary节点)上.
2. 所有的写操作发送到头结点,然后写入成功操作发送到下一个节点,直至发送到尾节点,由尾节点响应客户端.

### 新加follower
1. 从leader上复制某个时间点的快照.
2. 将快照复制到新增的follower上.
3. 接着follower需要连接上leader,并且请求快照之后所有的数据变化.这就需要快照指明复制日志的具体位置.
4. 然后follower需要执行快照以后的日志内容,直到追上leader,这个时候就可以正常的工作了.

### 处理节点故障
#### follower故障
由于follower都从leader那里同步了复制日志,因此可以很容易的通过复制日志进行恢复.恢复后还需要从leader那里获取故障之后发生的数据变化日志.执行完这些后,follower就能正常对外提供服务了.

#### leader故障
leader出现故障比较麻烦.首先需要新选择一个follower作为新的leader,然后客户端需要被重新配置,将写操作发往新的leader,最后其他的follower需要从新的leader同步数据.这被称为**故障转移**.故障转移操作可以是手动的,也可以是自动的,自动的操作如下:
1. 首先需要确定leader是否真的失效了,由于故障原因很多,例如leader崩溃了,断电了,网络问题或者其他.常用的策略就是通过心跳检测,来确认进程是否还活着.
2. 选择一个新的leader.新的leader可以通过一个选举过程选择,也可以是之前的leader指定的.最好是数据变化最接近原来的leader的follower被选为新的leader.如何让所有的节点同意这个新的leader,是一个**一致性(consensus)**问题.
3. 重新配置系统使用这个新的leader.客户端需要发送写操作到新的leader上,然后旧的leader即使恢复了,也要变成follower,并且认可新的leader.

故障转移过程里伴随着很多异常:
1. 如果采用了异步复制策略,新的leader也许会丢失之前写到旧的leader还没来及发送给其他follower的请求.最简单的措施就是,丢弃这些写操作.
2. 但是丢弃写操作将会导致很多问题,比如主键被重复使用了.
3. 在选择新leader的时候,可能会发生脑裂问题.安全起见,系统应该有一个机制就是自动关闭其中一个leader,保证系统只有一个leader.
4. 心跳的时长该怎么选择呢?如果心跳时长太长,导致故障恢复的时间会变长,如果心跳时长太短,会导致不必要的故障恢复操作.

由于这些问题并不是那么容易解决,因此很多时候,故障转移操作都是管理员手动去操作.**节点故障**,**不可靠网络**,**节点一致性权衡**,**持久化**,**可用性**以及**延迟**都是分布式系统不可避免的问题.

### 复制日志实现
#### 基于语句的复制
最简单的实现就是,将请求里的操作发送给各个follower,对于关系型数据库,就是将增删改查操作都发送给follower,让follower再执行一遍.尽管这个方法听起来很靠谱,但是操作起来就会发现问题.
1. 如果执行语句中包含非确定的函数,例如now(),rand(),那么数据肯定就不一致了.
2. 如果执行的语句需要依赖数据的当前状态,那么执行的顺序就非常重要了.一旦要求了执行顺序,那么并发执行事务就会很麻烦.
3. 有些执行的语句包含有副作用.除非这些副作用是确定的.

实际上,也不是没办法解决,对于那些非确定的操作,leader提前将这些操作的结果写回来替代这些操作.不过,其他的复制方法更好,所以不采用这些方法.

#### 预写日志的方式
leader可以将预写日志发送给follower,然后让follower重复执行日志内容.主要的问题在于,这些日志内容都是二进制格式,并且与存储引擎紧密相关.因此如果主从机器上的存储引擎版本不同,都有可能导致复制问题.这看起来是个小问题,但是想一下,如果版本是可以兼容的,那么我们可以做到无宕机升级操作,但是如果版本不兼容,那么我们不得不进行停机操作进行升级更新.

#### 逻辑日志方式
逻辑日志是为了和物理引擎的数据表达格式进行区分.一行逻辑日志内容,通常就是数据库里的一行数据.
1. 对于插入的行,那么日志内容包含每列的最新数据.
2. 对于删除行,日志包含标识该删除行的信息.如果有主键还好,没有主键的情况下,删除行的数据需要被记录下来.
3. 对于update操作,日志包含唯一标识改行的信息,并且包含更新的数据信息.

事务往往会更改多行数据,因此还需要记录事务提交的标识.binlog就是采用这种方式.由于逻辑日志与引擎内部实现无关,因此很容易做到向后兼容,因此避免了预写日志复制的问题.被用于建立数据仓库,索引和填充缓存.这种技术被称为**CDC(change data capture)**

#### 基于触发器的方式
有些时候,我们只希望复制部分的数据内容,这个时候我们就需要把复制工作上移到应用层来实现了.我们可以利用数据库里的**触发器**和**存储过程**来实现.当发生数据变更时,触发器被触发将执行指定的存储过程,将响应的变更写入其他的数据库里.但是这种方式也会带来额外的工作量,并且容易导致更多的bug.

### 复制日志的问题
我们需要复制操作的一个原因,就是为了能够容忍部分节点故障.当然还有扩张性和低延迟的考虑.主从结构中,写操作都只能到主节点上,读操作可以到任意节点.对于读操作多,写操作少的应用来说,设置很多follower能够极大的提高应用性能.当然在这种场景下,主从结构必须采用异步复制的模式.

然而,既然应用的读是从异步follower上读,那么就会出现follower上的数据落后于leader.因此当发送同一个请求到leader和follower上,就会发现结果可能会不一致,当然如果停止写操作然后等一会儿,follower慢慢会追上leader,然后两者的数据最终会完全一样.这被称为**最终一致性(eventual consistency)**.最终的意思其实就是说,不清楚到底何时会达到一致.一般来说,这个延迟很小,但是如果发生了节点故障或者网络问题,那么这个延迟有可能会很长.当延迟很明显的时候,就会导致一些问题.

#### 写后读一致性.
想象这样一种场景,你提交了一个写操作到leader节点,随后你预览你的写操作,请求被打到了follower上,由于复制延迟,你看不到你提交的写操作.这种被称为**read-after-write**一致性.
1. 当读取有可能更改的数据时,应该选择从leader节点返回数据.而数据是否可能更改,需要你自己提前去测试.
2. 但是如果应用中所有的操作都可能变化,那么1就不具备可操作性了.这个时候可以选择,在提交写操作后的一段时间内,所有请求都发往leader节点.或者根据可观测的复制延迟,来选择这个时间.
3. 也可以选择让客户端记录最近写操作的时间戳,当请求发送到follower时,只返回时间戳大于写操作时间戳的结果,如果没有就把请求转发给其他副本.或者可以等当前副本满足条件了再返回结果.时间戳可以使用逻辑时间戳(自定的序列号)或者实际系统时钟.
4. 如果副本部署在不同的机房,那么还必须保证发送到leader所在的机房.

当请求来自不同的设备的时候,这个问题会更棘手.因此又衍生出**cross-device read-after-write**一致性:
1. 不同设备只能记录自己更新的时间戳,没办法获知其他设备的更新时间戳.因此更新时间戳这种元数据还得提供一个中心化的服务来管理.
2. 如果数据分布在不同的机房.那么不同的设备就有可能被分配到不同的机房.那么你需要强制一个用户所有的设备的请求都分发到一个机房里.

#### 单调读一致性
由于读请求会被分发到不同的副本节点上,这会导致前一个请求获取到了数据,后一个请求就没数据了.单调读一致性比强一致性若,比最终一致性强.

为了保证单调读一致性,就需要保证请求始终发到同一个副本节点上.

#### 一致前缀读一致性
这种一致性要求,读取的顺序必须和写入的顺序是一致的.如果数据库没有分区,那么这种一致性很明显是满足的,但是对于有分区的分布式数据系统,某个分区